{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}

module Auction.Approvals 
    ( Approvals -- hide constructor
    , validateApprovees
    , pkhsForApprovals
    )
    where

import           Data.Aeson (FromJSON, ToJSON)
import           GHC.Generics (Generic)
import           Ledger ( PubKeyHash ) 
import qualified PlutusTx
import           PlutusTx.Prelude ( Eq, Ord, ($), foldr ) 
import qualified Prelude as P   
import           Schema (ToSchema)

import           Auction.Bidders ( Bidders )
import           Auction.TypesNonCertBidderStatus ( NotRegistereds(..), AlreadyApproveds(..) )


newtype Approvals = Approvals [PubKeyHash] 
    deriving stock (P.Eq, P.Ord, P.Show, Generic)
    deriving anyclass (ToJSON, FromJSON, ToSchema)
    deriving newtype (Eq, Ord, PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData)

PlutusTx.makeLift ''Approvals


validateApprovees :: Bidders -> [PubKeyHash] -> (Approvals, AlreadyApproveds, NotRegistereds)
validateApprovees b = foldr f (Approvals [], AlreadyApproveds [], NotRegistereds [])
    where f = \ x (Approvals as, AlreadyApproveds bs, NotRegistereds cs) ->
            if isBidderRegistered b x then    (Approvals $ x:as, AlreadyApproveds bs    , NotRegistereds cs    )
            else if isBidderApproved b x then (Approvals as    , AlreadyApproveds $ x:bs, NotRegistereds cs    )
            else                              (Approvals as    , AlreadyApproveds bs    , NotRegistereds $ x:cs)


{-# INLINABLE pkhsForApprovals #-}
pkhsForApprovals :: Approvals -> [PubKeyHash]
pkhsForApprovals (Approvals xs) = xs